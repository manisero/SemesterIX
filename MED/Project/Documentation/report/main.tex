\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[MeX]{polski}
\usepackage{tikz}
\usepackage{url}
\usepackage{fullpage}

\title{Projekt MED-P3, algorytm GRM. Raport. \\ \small{Przedmiot: Metody eksploracji danych w odkrywaniu wiedzy.}}
\author{Michał Aniserowicz, Jakub Turek}
\date{}

\begin{document}

\maketitle

\section{Opis zadania} \label{sec:task_desc}
Celem projektu jest zaimplementowanie algorytmu wyznaczania reguł decyzyjnych o minimalnych poprzednikach, które są częstymi generatorami.
Algorytm ten jest modyfikacją algorytmu odkrywania częstych generatorów (GRM), opisanego w~\cite{grm}.



\section{Założenia} \label{sec:assumptions}
Projekt zrealizowano w oparciu o następujące założenia:

\subsection*{Niefunkcjonalne:}
 \begin{enumerate}
  \item Użyty język programowania; platforma: C\#; .NET Framework 3.5.
  \item Obsługiwane systemy operacyjne: kompatybilne z .NET Framework 3.5\footnote{Lista systemów kompatybilnych z .NET Framework 3.5 dostępna jest pod adresem: \emph{http://msdn.microsoft.com/en-us/library/vstudio/bb882520\%28v=vs.90\%29.aspx}, sekcja ``Supported Operating Systems''.} (aplikację testowano na systemie Microsoft Windows 7 Ultimate).
  \item Rodzaj aplikacji: aplikacja konsolowa.
\end{enumerate}

\subsection*{Funkcjonalne:}
 \begin{enumerate}
  \item Aplikacja pobiera dane z pliku (patrz sekcja \ref{sec:io}).
  \item Aplikacja zwraca wynik działania w dwóch formatach: ``przyjaznym dla człowieka'' i ``excelowym'' (patrz sekcja \ref{sec:io}).
  \item Aplikacja pozwala mierzyć czas wykonania poszczególnych kroków algorytmu.
  \item Zakłada się, że każda transakcja zawarta w danych wejściowych ma przypisaną decyzję.
 \end{enumerate}



\section{Dane wejściowe i wyjściowe} \label{sec:io}
opis danych wejsciowych i wyjsciowych
- opcje (zostana opisane pozniej), minsup bezwzgledne!
- dane oddzielone przecinkami (decyzja razem z atrybutami, na dowolnym miejscu)
- naglowki w pierwszym wierszu
- brak danych - spacja (biale znaki)
- dwa formaty wynikow
- oprocz tego wynik na konsoli



\section{Implementacja}
wszystkie istotne kwestie zwiazne z projektowaniem (np. diagramy klas) i implementacja
projektowanie:
- podzial na moduly (console, dataset processing, GRM)
- testy
- diagram klas Logic
implementacja:
- jakis algorytm, moze z diffsetami
- rozne sortowania
- tidset/diffset
- bruteforce/inv list
- tracking (poziomy)

\subsection{Opymalizacje}
- wszystkie wartosci otrzymuja identyfikatory liczbowe
- skonfliktowane generatory
- transaction ids - posortowane (szybkie intersect, except)

roznice z GRM:
- dany node jest decyzyjny - nie rozwijamy go (bo generatory dzieci nie beda minimalne)
- generatory decyzji trzymane w slowniku (klucz - decyzja), posortowane wg hasha
- w ogole nie ma granicy
- dla diffsetow transaction ids trzymane w slowniku (klucz - decyzja)



\section{Podręcznik użytkownika}
podrecznik potencjalnego uzytkownika wytworzonego oprogramowania
(zamierzam korzystać z niego podczas sprawdzania Panstwa rozwiazan)
- wszystkie opcje programu
- przykladowa komenda i wynik na konsoli



\section{Analiza poprawności}
wszystkie wyniki wytwarzane przez program otrzymane dla malego,
przykladowego zbioru danych (w celu weryfikacji poprawnosci działania
programu)
- przyklad z konsultacji



\section{Analiza wydajności}
wyniki jakosciowe i ilosciowe na (np. czas dzialania; liczba wzorcow)
uzyskane dla wiekszych (wielkich) zbiorow danych(np. z
http://archive.ics.uci.edu/ml/ or http://fimi.cs.helsinki.fi/data/ lub
uzgodnionych już wcześniej ze mna podczas konsultacji projektowych)
- wykresy, wykresy
- ze dla duzej liczby atrybutow malo wydajny



\section{Wnioski}
wnioski z realizacji projektu
- ze trzeba by poprawic wykrywanie supergeneratorow
- ze ogolnie dziala spoczko (nursey)



\begin{thebibliography}{*}

 \bibitem{grm}
  \emph{Odkrywanie reprezentacji generatorowej wzorców częstych z wykorzystaniem struktur listowych},
  Kryszkiewicz M., Pielasa P.,
  Instytut Informatyki,
  Politechnika Warszawska.


\end{thebibliography}

\end{document}
