\documentclass{article}
\usepackage[MeX]{polski}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{amsmath}

\title{Dokumentacja końcowa projektu \\ \Large{Algorytm DSA}}
\author{Jakub Turek}
\date{}

\begin{document}

    \maketitle

    \section*{Podstawy teoretyczne}
    
        FIPS\footnote{Skrót od \textbf{F}ederal \textbf{I}nformation \textbf{P}rocessing \textbf{S}tandard (ang. federalny standard przetwarzania informacji).} jest zbiorem, w~którym opisane są publiczne standardy bezpieczeństwa używane przez federalny rząd Stanów Zjednoczonych. Oficjalnym standardem podpisywania wiadomości cyfrowych zamieszczonym w~FIPS jest DSS (ang. Digital Signature Standard). DSS opiera się o~algorytm DSA (ang. Digital Signature Algorithm).
    
        Standard DSS (wraz z~algorytmem DSA) został opisany w~dokumencie FIPS PUB 186\footnote{\url{http://www.itl.nist.gov/fipspubs/fip186.htm}.}. Na potrzeby projektu zaimplementowany został oryginalny algorytm opublikowany w~1994 roku, który wykorzystuje funkcję skrótu SHA.
        
    \subsection*{Algorytm}
    
        \paragraph*{Generacja kluczy} Należy wybrać parametry:
                    
        \begin{itemize}
            \item Liczba pierwsza $p$ w~pierścieniu reszt modulo $a$, gdzie $2^{L-1} < p < 2^{L}$ oraz $512 \leq L \leq 1024$ i~$L$ jest wielokrotnością 64.
            \item Liczba pierwsza $q$ będąca dzielnikiem liczby $p - 1$ w~pierścieniu reszt modulo $a$, gdzie $2^{159} < q < 2^{160}$.
            \item Liczba $g = h^{\frac{p-1}{q}} \pmod p$, gdzie $h$ jest dowolną liczbą naturalną spełniającą warunek $1 < h < p - 1$ taką, że $h^{\frac{p-1}{q}} \pmod p > 1$ (czyli $g$ ma rząd $q \pmod p$).
            \item Losowo wygenerowana liczba $x$ z~przedziału $0 < x < q$.
            \item Liczba $y = g^{x} \pmod p$.
            \item Losowo wygenerowana liczba $k$ z~przedziału $0 < k < q$.
        \end{itemize}
            
        Liczby $p$, $q$ oraz $g$ są publiczne. Klucz prywatny użytkownika to $x$, natomiast klucz publiczny użytkownika to $y$. Parametr $k$ musi być obliczany dla każdego nowego podpisu. Klucze są wielokrotnego użytku.
        
        \paragraph*{Podpisywanie wiadomości} Podpisem wiadomości $M$ jest para liczb $(r, s)$ obliczanych według poniższego wzoru:
        
        \begin{equation*}
            \begin{array}{lcl}
                r & = & (g^{k} \mod p) \mod q \\
                s & = & (k^{-1} (SHA(M) + xr)) \mod q \\
            \end{array}
        \end{equation*}
        
        \noindent gdzie $k^{-1}$ jest odwrotnością liczby $k$ w~pierścieniu reszt modulo $q$ (czyt. $k \cdot k^{-1} \equiv 1 \pmod q$). 
        
        Opcjonalnie można zweryfikować, czy $r \neq 0$ i~$s \neq 0$. Jeżeli jeden z~warunków nie jest spełniony, należy wygenerować podpis od nowa. Sytuacja taka nie powinna się jednak zdarzyć dla prawidłowo wygenerowanych kluczy.
        
        \paragraph*{Weryfikacja podpisu} Zakładamy, że otrzymaliśmy zestaw $(M', (r', s'))$ składający się z~wiadomości oraz podpisu tej wiadomości. Aby zweryfikować podpis należy:
        
        \begin{enumerate}
            \item Dokonać sprawdzenia, że $0 < r' < q$, a~ponadto $0 < s' < q$.
            \item Obliczyć poniższe wartości:
            
                \begin{equation*}
                    \begin{array}{lcl}
                        w & = & (s')^{-1} \pmod q \\
                        u_{1} & = & SHA(M') \cdot w \pmod q \\
                        u_{2} & = & r' \cdot w \pmod q \\
                        v & = & (g^{u_{1}} \cdot y^{u_{2}} \mod p) \pmod q \\
                    \end{array}
                \end{equation*}
            \item Sprawdzić, czy $v = r'$.
            \item Podpis jest prawidłowy, jeżeli warunek z~punktu 3. jest spełniony.
        \end{enumerate}
        
\end{document}